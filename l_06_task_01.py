# Урок 6, задача №1

# Подсчитать, сколько было выделено памяти под переменные
# в ранее разработанных программах в рамках первых трех уроков.
# Проанализировать результат и определить программы
# с наиболее эффективным использованием памяти.
# Примечание: По аналогии с эмпирической оценкой алгоритмов
# идеальным решением будет:
# выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
# написать 3 варианта кода (один у вас уже есть);
# проанализировать 3 варианта и выбрать оптимальный;
# результаты анализа (количество занятой памяти в вашей среде
# разработки) вставить в виде комментариев в файл с кодом.
# Не забудьте указать версию и разрядность вашей ОС
# и интерпретатора Python;
# написать общий вывод: какой из трёх вариантов лучше и почему.
#

import sys


def show_sum(x):
    size_sum = sys.getsizeof(x)
    if hasattr(x, '__iter__'):
        if hasattr(x, 'items'):
            for key, val in x.items():
                size_sum += sys.getsizeof(key)
                size_sum += sys.getsizeof(val)
        elif not isinstance(x, str):
            for item in x:
                size_sum += sys.getsizeof(item)
    print(f'type={type(x)}, obj={x}, total size={size_sum}')
    return size_sum

input_array = [39, -2, 76, -45, 31, -16, -63, -40, -17, 20]


# алгоритм А-1 - ГЕНЕРАТОР СПИСКА ИЗ ИНДЕКСОВ ЧЕТНЫХ ЭЛЕМЕНТОВ
def evens_gen(array):
    result = [i for i in range(len(array)) if array[i] % 2 == 0]
    # подсчет памяти, выделенной под переменные
    for val in locals().values():
        show_sum(val)
    return result


# алгоритм А-2 - ОБХОД СПИСКА ЦИКЛОМ FOR IN,
# ЗАПИСЬ ИНДЕКСОВ ВЫБРАННЫХ ЭЛЕМЕНТОВ В НОВЫЙ СПИСОК
def evens_cyc(array):
    result = []
    for i in range(len(array)):
        if array[i] % 2 == 0:
            result.append(i)
    # подсчет памяти, выделенной под переменные
    for val in locals().values():
        show_sum(val)
    return result


# алгоритм А-3 - С СОХРАНЕНИЕМ ЧЕТНЫХ ЭЛЕМЕНТОВ В СЛОВАРЕ
def evens_dic(array):
    spam = {}
    result = []
    for i, item in enumerate(array):
        if item % 2 == 0:
            spam[i] = item
    for key in spam:
        result.append(key)
    # подсчет памяти, выделенной под переменные
    for val in locals().values():
        show_sum(val)
    return result


evens_gen(input_array)
print('*' * 50)
evens_cyc(input_array)
print('*' * 50)
evens_dic(input_array)

# **************************************************************:
# Условия анализа: Linux 64-bit, Python 3.7
# **************************************************************:
# для анализа выбрана задача №2 к уроку 3 -
# во втором массиве сохранить индексы четных элементов первого массива.

# АЛГОРИТМ А-1 использует генератор списка
# АЛГОРИТМ А-2 использует итерацию по входному массиву
# АЛГОРИТМ А-3 использует промежуточный словарь

# размер исходного массива в каждом случае одинаков и составляет 432 байта
# размер массива на выходе также одинаков - 276 байт
# За вычетом указанных массивов, объем памяти, используемый под переменные, составил:
# А-1: 0 байт (временные переменные генератора после использования удаляются из памяти)
# А-2: 28 байт (1 переменная INT, используемая для итерации)
# А-3: 612 байт (528 байт - временный словарь, 3 * 28 байт - переменные INT, используемые для итерации)

# ВЫВОД:
# использование временного словаря в алгоритме А-3 приводит к значительному расходу памяти
# наиболее оптимальный алгоритм по использованию памяти - А-1 (генератор списка)
